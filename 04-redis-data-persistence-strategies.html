<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Data Persistence Strategies: Ensuring Your Data Survives</title>
</head>
<body>
    <header>
        <h1>Redis Data Persistence Strategies: Ensuring Your Data Survives</h1>
        <p><em>Master RDB snapshots, AOF logging, and hybrid approaches to protect your Redis data</em></p>
        <p><strong>Published:</strong> Blog Post #4 of Redis Mastery Series</p>
    </header>

    <main>
        <section>
            <h2>Introduction</h2>
            <p>Redis is primarily an in-memory database, which means all data is stored in RAM for lightning-fast access. However, this raises a critical question: what happens to your data when Redis restarts, crashes, or the server loses power? Without proper persistence strategies, you could lose everything.</p>
            
            <p>Fortunately, Redis provides robust persistence mechanisms to ensure your data survives system failures. In this comprehensive guide, we'll explore Redis's persistence options, learn how to configure them for different scenarios, and establish bulletproof backup and recovery procedures.</p>
            
            <p>Understanding persistence is crucial for any production Redis deployment. The right persistence strategy can mean the difference between a minor service interruption and catastrophic data loss.</p>
        </section>

        <section>
            <h2>Understanding Redis Persistence</h2>
            
            <h3>The Challenge of In-Memory Storage</h3>
            <p>Redis stores all data in memory for performance, but this creates durability challenges:</p>
            <ul>
                <li><strong>Volatility:</strong> RAM contents are lost when power is removed</li>
                <li><strong>Process crashes:</strong> Application or system failures can terminate Redis</li>
                <li><strong>System reboots:</strong> Maintenance and updates require restarts</li>
                <li><strong>Hardware failures:</strong> Memory corruption or hardware issues</li>
            </ul>

            <h3>Redis Persistence Options</h3>
            <p>Redis offers three main persistence strategies:</p>
            
            <table border="1">
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                <tr>
                    <td><strong>RDB Snapshots</strong></td>
                    <td>Point-in-time snapshots of the dataset</td>
                    <td>Compact, fast recovery, good for backups</td>
                    <td>Potential data loss between snapshots</td>
                </tr>
                <tr>
                    <td><strong>AOF Logging</strong></td>
                    <td>Append-only log of all write operations</td>
                    <td>Better durability, minimal data loss</td>
                    <td>Larger files, slower recovery</td>
                </tr>
                <tr>
                    <td><strong>Mixed Mode</strong></td>
                    <td>Combination of RDB and AOF</td>
                    <td>Best of both worlds</td>
                    <td>More complex configuration</td>
                </tr>
            </table>

            <h3>Choosing the Right Strategy</h3>
            <p>Your choice depends on several factors:</p>
            <ul>
                <li><strong>Data importance:</strong> Can you afford to lose some data?</li>
                <li><strong>Performance requirements:</strong> How much overhead can you tolerate?</li>
                <li><strong>Recovery time objectives:</strong> How quickly must you recover?</li>
                <li><strong>Storage constraints:</strong> How much disk space is available?</li>
                <li><strong>Backup requirements:</strong> How often do you need backups?</li>
            </ul>
        </section>

        <section>
            <h2>RDB Snapshots: Point-in-Time Backups</h2>
            
            <h3>How RDB Works</h3>
            <p>RDB (Redis Database) creates binary snapshots of your entire dataset at specific points in time. These snapshots are compact, efficient, and perfect for backup purposes.</p>
            
            <h4>RDB Process</h4>
            <ol>
                <li>Redis forks a child process</li>
                <li>Child process writes the dataset to a temporary RDB file</li>
                <li>Once complete, the temporary file replaces the old RDB file</li>
                <li>Parent process continues serving clients without interruption</li>
            </ol>

            <h3>RDB Configuration</h3>
            
            <h4>Basic RDB Settings</h4>
            <pre><code># redis.conf settings for RDB

# Snapshot frequency: save <seconds> <changes>
save 900 1      # Save if at least 1 key changed in 900 seconds (15 minutes)
save 300 10     # Save if at least 10 keys changed in 300 seconds (5 minutes)
save 60 10000   # Save if at least 10000 keys changed in 60 seconds (1 minute)

# RDB file settings
dbfilename dump.rdb
dir /var/lib/redis/

# Compression (recommended)
rdbcompression yes

# Checksum verification (recommended)
rdbchecksum yes

# Stop accepting writes if RDB save fails
stop-writes-on-bgsave-error yes</code></pre>

            <h4>Advanced RDB Configuration</h4>
            <pre><code># Fine-tune RDB behavior

# RDB save frequency
save 3600 1     # Hourly if any changes
save 900 10     # Every 15 minutes if 10+ changes  
save 300 100    # Every 5 minutes if 100+ changes
save 60 1000    # Every minute if 1000+ changes

# Or disable automatic saves
# save ""

# File permissions
# Make sure Redis user can write to the directory
# chown redis:redis /var/lib/redis
# chmod 750 /var/lib/redis

# Memory optimization during save
rdb-save-incremental-fsync yes</code></pre>

            <h3>Manual RDB Operations</h3>
            
            <h4>Triggering Manual Snapshots</h4>
            <pre><code># Create immediate snapshot (blocking)
SAVE

# Create background snapshot (non-blocking)
BGSAVE

# Check if background save is in progress
LASTSAVE    # Returns timestamp of last successful save

# Get background save status
INFO persistence | grep rdb_bgsave_in_progress</code></pre>

            <h4>RDB File Management</h4>
            <pre><code># Check RDB file information
CONFIG GET dir          # Get RDB directory
CONFIG GET dbfilename   # Get RDB filename

# Get last save information
INFO persistence | grep rdb_last_save_time
INFO persistence | grep rdb_last_bgsave_status

# Monitor RDB metrics
INFO persistence | grep rdb_changes_since_last_save</code></pre>

            <h3>RDB Use Cases and Best Practices</h3>
            
            <h4>When to Use RDB</h4>
            <ul>
                <li><strong>Backup strategy:</strong> Regular snapshots for disaster recovery</li>
                <li><strong>Data archival:</strong> Long-term storage of historical data</li>
                <li><strong>Replication:</strong> Fast initial sync for slaves</li>
                <li><strong>Development/testing:</strong> Quick dataset copying</li>
                <li><strong>Low write volume:</strong> When data doesn't change frequently</li>
            </ul>

            <h4>RDB Best Practices</h4>
            <pre><code># Production RDB configuration example
save 900 1
save 300 10  
save 60 1000

# Enable compression and checksums
rdbcompression yes
rdbchecksum yes

# Handle save failures appropriately
stop-writes-on-bgsave-error yes

# Store RDB files on separate disk for performance
dir /backup/redis/

# Regular backup script
#!/bin/bash
BACKUP_DIR="/backups/redis/$(date +%Y%m%d)"
mkdir -p $BACKUP_DIR
redis-cli BGSAVE
sleep 10  # Wait for save to complete
cp /var/lib/redis/dump.rdb $BACKUP_DIR/dump_$(date +%H%M%S).rdb</code></pre>

            <h3>RDB Advantages and Limitations</h3>
            
            <h4>Advantages</h4>
            <ul>
                <li><strong>Compact files:</strong> Efficient binary format</li>
                <li><strong>Fast recovery:</strong> Quick loading on restart</li>
                <li><strong>Good for backups:</strong> Easy to copy and archive</li>
                <li><strong>Minimal performance impact:</strong> Fork-based background saving</li>
                <li><strong>Disaster recovery:</strong> Perfect for off-site backups</li>
            </ul>

            <h4>Limitations</h4>
            <ul>
                <li><strong>Data loss potential:</strong> May lose data between snapshots</li>
                <li><strong>Fork overhead:</strong> Can be expensive on large datasets</li>
                <li><strong>Disk I/O spikes:</strong> Periodic intensive disk activity</li>
                <li><strong>Not real-time:</strong> Not suitable for zero data loss requirements</li>
            </ul>
        </section>

        <section>
            <h2>AOF Logging: Append-Only Durability</h2>
            
            <h3>How AOF Works</h3>
            <p>AOF (Append-Only File) logs every write operation received by Redis. This creates a complete history of commands that can be replayed to reconstruct the dataset.</p>
            
            <h4>AOF Process</h4>
            <ol>
                <li>Client sends write command to Redis</li>
                <li>Redis executes the command and updates memory</li>
                <li>Redis appends the command to the AOF buffer</li>
                <li>Buffer is flushed to disk based on fsync policy</li>
                <li>Periodic AOF rewriting optimizes the file</li>
            </ol>

            <h3>AOF Configuration</h3>
            
            <h4>Basic AOF Settings</h4>
            <pre><code># redis.conf settings for AOF

# Enable AOF
appendonly yes

# AOF filename
appendfilename "appendonly.aof"

# Directory (same as RDB)
dir /var/lib/redis/

# Fsync policy - CRITICAL SETTING
appendfsync everysec    # Recommended: fsync every second
# appendfsync always    # Fsync after every command (slowest, safest)
# appendfsync no        # Let OS decide when to fsync (fastest, least safe)

# Handle write errors
no-appendfsync-on-rewrite no

# Automatic AOF rewrite
auto-aof-rewrite-percentage 100  # Rewrite when file is 100% larger
auto-aof-rewrite-min-size 64mb   # Minimum size before rewrite</code></pre>

            <h4>AOF Fsync Policies Explained</h4>
            <table border="1">
                <tr>
                    <th>Policy</th>
                    <th>Description</th>
                    <th>Durability</th>
                    <th>Performance</th>
                    <th>Data Loss Risk</th>
                </tr>
                <tr>
                    <td><strong>always</strong></td>
                    <td>Fsync after every command</td>
                    <td>Maximum</td>
                    <td>Slowest</td>
                    <td>~0 commands</td>
                </tr>
                <tr>
                    <td><strong>everysec</strong></td>
                    <td>Fsync once per second</td>
                    <td>Good</td>
                    <td>Fast</td>
                    <td>~1 second of data</td>
                </tr>
                <tr>
                    <td><strong>no</strong></td>
                    <td>Let OS decide</td>
                    <td>Minimal</td>
                    <td>Fastest</td>
                    <td>~30 seconds of data</td>
                </tr>
            </table>

            <h3>AOF Rewriting and Optimization</h3>
            
            <h4>Understanding AOF Rewriting</h4>
            <p>Over time, AOF files grow large because they contain the full history of operations. Rewriting creates a new, optimized AOF file with the minimal set of commands needed to recreate the current dataset.</p>
            
            <pre><code># Example of AOF growth and rewriting

# Original commands in AOF:
SET counter 1
INCR counter     # counter = 2
INCR counter     # counter = 3
INCR counter     # counter = 4
INCR counter     # counter = 5

# After rewrite, AOF contains only:
SET counter 5</code></pre>

            <h4>Manual AOF Operations</h4>
            <pre><code># Trigger manual AOF rewrite
BGREWRITEAOF

# Check AOF rewrite status
INFO persistence | grep aof_rewrite_in_progress

# Get AOF statistics
INFO persistence | grep aof_current_size
INFO persistence | grep aof_base_size

# Force AOF fsync (if using appendfsync no)
CONFIG SET appendfsync everysec</code></pre>

            <h4>AOF Rewrite Configuration</h4>
            <pre><code># Advanced AOF rewrite settings

# Automatic rewrite triggers
auto-aof-rewrite-percentage 100    # Rewrite when 100% larger than base size
auto-aof-rewrite-min-size 64mb     # Don't rewrite if smaller than 64MB

# Performance during rewrite
no-appendfsync-on-rewrite no       # Continue fsync during rewrite
aof-rewrite-incremental-fsync yes  # Incremental fsync during rewrite

# AOF loading
aof-load-truncated yes             # Load truncated AOF files (corruption recovery)</code></pre>

            <h3>AOF File Management</h3>
            
            <h4>AOF File Operations</h4>
            <pre><code># Check AOF file integrity
redis-check-aof appendonly.aof

# Fix corrupted AOF file
redis-check-aof --fix appendonly.aof

# Get AOF file information
ls -lh /var/lib/redis/appendonly.aof

# Monitor AOF in real-time
tail -f /var/lib/redis/appendonly.aof</code></pre>

            <h4>AOF Backup and Recovery</h4>
            <pre><code># Backup AOF file
cp /var/lib/redis/appendonly.aof /backup/appendonly_$(date +%Y%m%d_%H%M%S).aof

# Recovery from AOF
# 1. Stop Redis
# 2. Replace appendonly.aof with backup
# 3. Start Redis

# AOF to RDB conversion
redis-cli --rdb backup.rdb &  # Start RDB generation
redis-cli BGREWRITEAOF        # Rewrite AOF
# Now you have both formats</code></pre>

            <h3>AOF Use Cases and Best Practices</h3>
            
            <h4>When to Use AOF</h4>
            <ul>
                <li><strong>High durability needs:</strong> Minimal acceptable data loss</li>
                <li><strong>Audit trails:</strong> Need command history for compliance</li>
                <li><strong>Real-time applications:</strong> Cannot afford significant data loss</li>
                <li><strong>Financial systems:</strong> Every transaction must be preserved</li>
                <li><strong>Incremental backups:</strong> Want to capture all changes</li>
            </ul>

            <h4>AOF Best Practices</h4>
            <pre><code># Production AOF configuration
appendonly yes
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
no-appendfsync-on-rewrite no
aof-rewrite-incremental-fsync yes

# Monitoring script for AOF
#!/bin/bash
AOF_SIZE=$(redis-cli INFO persistence | grep aof_current_size | cut -d: -f2)
BASE_SIZE=$(redis-cli INFO persistence | grep aof_base_size | cut -d: -f2)
RATIO=$((AOF_SIZE * 100 / BASE_SIZE))

if [ $RATIO -gt 300 ]; then
    echo "AOF file is getting large (${RATIO}% of base), consider rewrite"
    redis-cli BGREWRITEAOF
fi</code></pre>

            <h3>AOF Advantages and Limitations</h3>
            
            <h4>Advantages</h4>
            <ul>
                <li><strong>Better durability:</strong> Minimal data loss potential</li>
                <li><strong>Readable format:</strong> Human-readable command log</li>
                <li><strong>Flexible recovery:</strong> Can replay partial logs</li>
                <li><strong>Audit trail:</strong> Complete operation history</li>
                <li><strong>No corruption issues:</strong> Append-only nature prevents corruption</li>
            </ul>

            <h4>Limitations</h4>
            <ul>
                <li><strong>Larger files:</strong> Can grow very large over time</li>
                <li><strong>Slower recovery:</strong> Must replay all commands</li>
                <li><strong>Performance overhead:</strong> Additional disk I/O for every write</li>
                <li><strong>Disk space:</strong> Requires more storage than RDB</li>
            </ul>
        </section>

        <section>
            <h2>Mixed Persistence: Best of Both Worlds</h2>
            
            <h3>Understanding Mixed Mode</h3>
            <p>Redis 4.0 introduced mixed persistence, combining RDB snapshots with AOF logging to provide both fast recovery and high durability.</p>
            
            <h4>How Mixed Mode Works</h4>
            <ol>
                <li>AOF is enabled for durability</li>
                <li>AOF rewrite creates an RDB snapshot</li>
                <li>Incremental changes are appended as AOF commands</li>
                <li>Recovery loads RDB snapshot then replays AOF increments</li>
            </ol>

            <h3>Mixed Mode Configuration</h3>
            
            <h4>Enabling Mixed Mode</h4>
            <pre><code># redis.conf for mixed persistence

# Enable AOF
appendonly yes

# Enable RDB format in AOF rewrite
aof-use-rdb-preamble yes

# AOF settings
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# RDB settings (still used for regular snapshots)
save 900 1
save 300 10
save 60 1000

# File settings
appendfilename "appendonly.aof"
dbfilename "dump.rdb"
dir /var/lib/redis/</code></pre>

            <h4>Mixed Mode File Structure</h4>
            <pre><code># AOF file with RDB preamble structure:
# [RDB binary data]
# [AOF commands after last rewrite]

# Example file content:
REDIS0009ú      redis-ver5.0.7ú
redis-bitsÀ@ú   ctime°bÆ^ú      # RDB binary section
used-memÂÀ0 ú   aof-preambleÀÿ  
*3                              # AOF commands section
$3
SET
$4
key1
$6
value1</code></pre>

            <h3>Mixed Mode Operations</h3>
            
            <h4>Monitoring Mixed Mode</h4>
            <pre><code># Check if mixed mode is enabled
CONFIG GET aof-use-rdb-preamble

# Monitor mixed AOF statistics
INFO persistence | grep aof_rewrite_in_progress
INFO persistence | grep aof_current_size
INFO persistence | grep rdb_last_save_time

# Check file composition
file /var/lib/redis/appendonly.aof  # Should show "data" for RDB preamble</code></pre>

            <h4>Recovery with Mixed Mode</h4>
            <pre><code># Recovery process is automatic:
# 1. Redis loads RDB preamble (fast)
# 2. Redis replays AOF commands (minimal)
# 3. Normal operation begins

# Check recovery status
INFO persistence | grep loading
INFO persistence | grep aof_last_load_time</code></pre>

            <h3>Mixed Mode Benefits</h3>
            
            <table border="1">
                <tr>
                    <th>Aspect</th>
                    <th>RDB Only</th>
                    <th>AOF Only</th>
                    <th>Mixed Mode</th>
                </tr>
                <tr>
                    <td><strong>Recovery Speed</strong></td>
                    <td>Fast</td>
                    <td>Slow</td>
                    <td>Fast</td>
                </tr>
                <tr>
                    <td><strong>Durability</strong></td>
                    <td>Poor</td>
                    <td>Excellent</td>
                    <td>Excellent</td>
                </tr>
                <tr>
                    <td><strong>File Size</strong></td>
                    <td>Small</td>
                    <td>Large</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td><strong>Backup Efficiency</strong></td>
                    <td>Excellent</td>
                    <td>Poor</td>
                    <td>Good</td>
                </tr>
                <tr>
                    <td><strong>Complexity</strong></td>
                    <td>Low</td>
                    <td>Medium</td>
                    <td>Medium</td>
                </tr>
            </table>
        </section>

        <section>
            <h2>Backup and Recovery Strategies</h2>
            
            <h3>Comprehensive Backup Strategy</h3>
            
            <h4>Multi-Level Backup Approach</h4>
            <ol>
                <li><strong>Local snapshots:</strong> Frequent RDB snapshots on same server</li>
                <li><strong>Remote backups:</strong> Copy files to separate servers/storage</li>
                <li><strong>Point-in-time recovery:</strong> Combination of RDB + AOF</li>
                <li><strong>Cross-region replication:</strong> Geographic distribution</li>
            </ol>

            <h3>Automated Backup Scripts</h3>
            
            <h4>Complete Backup Script</h4>
            <pre><code>#!/bin/bash
# Complete Redis backup script

# Configuration
REDIS_HOST="localhost"
REDIS_PORT="6379"
REDIS_AUTH=""
BACKUP_DIR="/backups/redis"
RETENTION_DAYS=30
DATE=$(date +%Y%m%d_%H%M%S)

# Create backup directory
mkdir -p "$BACKUP_DIR/$DATE"

# Function to log messages
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Test Redis connectivity
if ! redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} ping >/dev/null 2>&1; then
    log "ERROR: Cannot connect to Redis"
    exit 1
fi

log "Starting Redis backup to $BACKUP_DIR/$DATE"

# Trigger background save
log "Triggering BGSAVE"
redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} BGSAVE

# Wait for save to complete
log "Waiting for BGSAVE to complete"
while [ "$(redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} LASTSAVE)" = "$(redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} LASTSAVE)" ]; do
    sleep 2
done

# Copy RDB file
if [ -f "/var/lib/redis/dump.rdb" ]; then
    log "Copying RDB file"
    cp /var/lib/redis/dump.rdb "$BACKUP_DIR/$DATE/dump.rdb"
    gzip "$BACKUP_DIR/$DATE/dump.rdb"
fi

# Copy AOF file if it exists
if [ -f "/var/lib/redis/appendonly.aof" ]; then
    log "Copying AOF file"
    cp /var/lib/redis/appendonly.aof "$BACKUP_DIR/$DATE/appendonly.aof"
    gzip "$BACKUP_DIR/$DATE/appendonly.aof"
fi

# Copy configuration
if [ -f "/etc/redis/redis.conf" ]; then
    log "Copying configuration"
    cp /etc/redis/redis.conf "$BACKUP_DIR/$DATE/redis.conf"
fi

# Create backup metadata
cat > "$BACKUP_DIR/$DATE/backup_info.txt" << EOF
Backup Date: $DATE
Redis Host: $REDIS_HOST:$REDIS_PORT
Redis Version: $(redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} INFO server | grep redis_version | cut -d: -f2 | tr -d '\r')
Database Size: $(redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} DBSIZE)
Memory Usage: $(redis-cli -h $REDIS_HOST -p $REDIS_PORT ${REDIS_AUTH:+-a $REDIS_AUTH} INFO memory | grep used_memory_human | cut -d: -f2 | tr -d '\r')
EOF

# Clean up old backups
log "Cleaning up backups older than $RETENTION_DAYS days"
find "$BACKUP_DIR" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \; 2>/dev/null

log "Backup completed successfully"

# Optional: Upload to cloud storage
# aws s3 sync "$BACKUP_DIR/$DATE" s3://my-redis-backups/$DATE/
# rsync -av "$BACKUP_DIR/$DATE/" backup-server:/redis-backups/$DATE/</code></pre>

            <h4>Incremental Backup Script</h4>
            <pre><code>#!/bin/bash
# Incremental AOF backup script

REDIS_DIR="/var/lib/redis"
BACKUP_DIR="/backups/redis/incremental"
DATE=$(date +%Y%m%d_%H%M%S)

# Create incremental backup directory
mkdir -p "$BACKUP_DIR"

# Copy current AOF
if [ -f "$REDIS_DIR/appendonly.aof" ]; then
    # Get file size for comparison
    CURRENT_SIZE=$(stat -c%s "$REDIS_DIR/appendonly.aof")
    LAST_SIZE_FILE="$BACKUP_DIR/last_aof_size"
    
    # Read last backup size
    if [ -f "$LAST_SIZE_FILE" ]; then
        LAST_SIZE=$(cat "$LAST_SIZE_FILE")
    else
        LAST_SIZE=0
    fi
    
    # Only backup if file has grown
    if [ $CURRENT_SIZE -gt $LAST_SIZE ]; then
        echo "AOF has grown from $LAST_SIZE to $CURRENT_SIZE bytes"
        
        # Create incremental backup using tail
        DIFF_SIZE=$((CURRENT_SIZE - LAST_SIZE))
        tail -c $DIFF_SIZE "$REDIS_DIR/appendonly.aof" > "$BACKUP_DIR/aof_increment_$DATE"
        
        # Update size tracking
        echo $CURRENT_SIZE > "$LAST_SIZE_FILE"
        
        echo "Incremental backup created: aof_increment_$DATE"
    else
        echo "No changes since last backup"
    fi
fi</code></pre>

            <h3>Recovery Procedures</h3>
            
            <h4>Complete Recovery Process</h4>
            <pre><code>#!/bin/bash
# Redis recovery script

BACKUP_DIR="/backups/redis"
REDIS_DIR="/var/lib/redis"
REDIS_CONF="/etc/redis/redis.conf"

# Function to stop Redis safely
stop_redis() {
    echo "Stopping Redis..."
    systemctl stop redis-server
    # or: redis-cli SHUTDOWN SAVE
}

# Function to start Redis
start_redis() {
    echo "Starting Redis..."
    systemctl start redis-server
}

# Recovery function
recover_from_backup() {
    local backup_date=$1
    
    if [ ! -d "$BACKUP_DIR/$backup_date" ]; then
        echo "Backup directory not found: $BACKUP_DIR/$backup_date"
        exit 1
    fi
    
    echo "Recovering from backup: $backup_date"
    
    # Stop Redis
    stop_redis
    
    # Backup current files (just in case)
    if [ -f "$REDIS_DIR/dump.rdb" ]; then
        mv "$REDIS_DIR/dump.rdb" "$REDIS_DIR/dump.rdb.backup"
    fi
    if [ -f "$REDIS_DIR/appendonly.aof" ]; then
        mv "$REDIS_DIR/appendonly.aof" "$REDIS_DIR/appendonly.aof.backup"
    fi
    
    # Restore RDB if available
    if [ -f "$BACKUP_DIR/$backup_date/dump.rdb.gz" ]; then
        echo "Restoring RDB file..."
        gunzip -c "$BACKUP_DIR/$backup_date/dump.rdb.gz" > "$REDIS_DIR/dump.rdb"
        chown redis:redis "$REDIS_DIR/dump.rdb"
    fi
    
    # Restore AOF if available
    if [ -f "$BACKUP_DIR/$backup_date/appendonly.aof.gz" ]; then
        echo "Restoring AOF file..."
        gunzip -c "$BACKUP_DIR/$backup_date/appendonly.aof.gz" > "$REDIS_DIR/appendonly.aof"
        chown redis:redis "$REDIS_DIR/appendonly.aof"
    fi
    
    # Restore configuration if needed
    if [ -f "$BACKUP_DIR/$backup_date/redis.conf" ] && [ "$2" = "--restore-config" ]; then
        echo "Restoring configuration..."
        cp "$BACKUP_DIR/$backup_date/redis.conf" "$REDIS_CONF"
    fi
    
    # Start Redis
    start_redis
    
    # Verify recovery
    sleep 5
    if redis-cli ping >/dev/null 2>&1; then
        echo "Recovery successful!"
        echo "Database size: $(redis-cli DBSIZE)"
    else
        echo "Recovery failed - Redis is not responding"
        exit 1
    fi
}

# Usage
if [ $# -lt 1 ]; then
    echo "Usage: $0 <backup_date> [--restore-config]"
    echo "Available backups:"
    ls -1 "$BACKUP_DIR" | grep -E '^[0-9]{8}_[0-9]{6}$' | sort -r | head -10
    exit 1
fi

recover_from_backup $1 $2</code></pre>

            <h4>Point-in-Time Recovery</h4>
            <pre><code># Point-in-time recovery process

# 1. Find the right backup
ls -la /backups/redis/

# 2. Check backup contents
cat /backups/redis/20231201_143000/backup_info.txt

# 3. Stop Redis
sudo systemctl stop redis-server

# 4. Clear current data
sudo rm -f /var/lib/redis/dump.rdb /var/lib/redis/appendonly.aof

# 5. Restore base snapshot
sudo gunzip -c /backups/redis/20231201_143000/dump.rdb.gz > /var/lib/redis/dump.rdb

# 6. Apply incremental AOF if needed
cat /backups/redis/incremental/aof_increment_* > /var/lib/redis/appendonly.aof

# 7. Fix permissions
sudo chown redis:redis /var/lib/redis/*

# 8. Start Redis
sudo systemctl start redis-server

# 9. Verify data
redis-cli DBSIZE
redis-cli GET some_test_key</code></pre>
        </section>

        <section>
            <h2>Production Configuration Examples</h2>
            
            <h3>High Durability Configuration</h3>
            
            <h4>Financial/Mission-Critical Systems</h4>
            <pre><code># redis.conf for maximum durability

# Enable both RDB and AOF
save 900 1
save 300 10
save 60 1000

appendonly yes
appendfsync always  # Maximum durability
aof-use-rdb-preamble yes

# Conservative rewrite settings
auto-aof-rewrite-percentage 200
auto-aof-rewrite-min-size 128mb
no-appendfsync-on-rewrite yes

# Error handling
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes

# File settings
dir /data/redis
dbfilename dump.rdb
appendfilename appendonly.aof

# Memory management
maxmemory-policy noeviction  # Never lose data

# Logging
loglevel notice
logfile /var/log/redis/redis-server.log

# Security
requirepass your_secure_password</code></pre>

            <h3>Balanced Performance Configuration</h3>
            
            <h4>Most Production Systems</h4>
            <pre><code># redis.conf for balanced performance/durability

# Moderate RDB frequency
save 3600 1
save 900 10
save 300 1000

# AOF with good performance
appendonly yes
appendfsync everysec  # Good balance
aof-use-rdb-preamble yes

# Standard rewrite settings
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
no-appendfsync-on-rewrite no

# Performance optimizations
rdbcompression yes
rdbchecksum yes
aof-rewrite-incremental-fsync yes
rdb-save-incremental-fsync yes

# Memory settings
maxmemory 2gb
maxmemory-policy allkeys-lru

# File locations
dir /var/lib/redis
dbfilename dump.rdb
appendfilename appendonly.aof</code></pre>

            <h3>High Performance Configuration</h3>
            
            <h4>Cache/Session Storage</h4>
            <pre><code># redis.conf for maximum performance

# Minimal RDB snapshots
save 3600 1
save ""  # Disable automatic saves for maximum performance

# AOF for basic durability
appendonly yes
appendfsync no  # Let OS handle fsync
aof-use-rdb-preamble yes

# Aggressive rewrite settings
auto-aof-rewrite-percentage 300
auto-aof-rewrite-min-size 256mb
no-appendfsync-on-rewrite yes

# Performance optimizations
rdbcompression no  # Faster saves
rdbchecksum no     # Skip checksums
tcp-nodelay yes    # Reduce latency

# Memory settings for cache
maxmemory 4gb
maxmemory-policy allkeys-lru

# Reduce disk I/O
stop-writes-on-bgsave-error no</code></pre>
        </section>

        <section>
            <h2>Monitoring and Alerting</h2>
            
            <h3>Key Persistence Metrics</h3>
            
            <h4>Essential Monitoring Commands</h4>
            <pre><code># Check persistence status
INFO persistence

# Key metrics to monitor:
rdb_last_save_time          # Last successful RDB save
rdb_last_bgsave_status      # Status of last background save
rdb_bgsave_in_progress      # Is background save running?
aof_enabled                 # Is AOF enabled?
aof_rewrite_in_progress     # Is AOF rewrite running?
aof_last_rewrite_time_sec   # Time taken for last AOF rewrite
aof_current_size            # Current AOF file size
aof_base_size              # AOF size after last rewrite</code></pre>

            <h4>Monitoring Script</h4>
            <pre><code>#!/bin/bash
# Redis persistence monitoring script

REDIS_HOST="localhost"
REDIS_PORT="6379"

# Get persistence info
PERSISTENCE_INFO=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO persistence)

# Extract key metrics
RDB_LAST_SAVE=$(echo "$PERSISTENCE_INFO" | grep rdb_last_save_time | cut -d: -f2)
RDB_STATUS=$(echo "$PERSISTENCE_INFO" | grep rdb_last_bgsave_status | cut -d: -f2 | tr -d '\r')
AOF_SIZE=$(echo "$PERSISTENCE_INFO" | grep aof_current_size | cut -d: -f2)
AOF_BASE_SIZE=$(echo "$PERSISTENCE_INFO" | grep aof_base_size | cut -d: -f2)

# Current time
CURRENT_TIME=$(date +%s)

# Check if last save is too old (24 hours = 86400 seconds)
SAVE_AGE=$((CURRENT_TIME - RDB_LAST_SAVE))
if [ $SAVE_AGE -gt 86400 ]; then
    echo "WARNING: Last RDB save was $((SAVE_AGE / 3600)) hours ago"
fi

# Check RDB save status
if [ "$RDB_STATUS" != "ok" ]; then
    echo "ERROR: Last RDB save failed with status: $RDB_STATUS"
fi

# Check AOF growth
if [ $AOF_SIZE -gt 0 ] && [ $AOF_BASE_SIZE -gt 0 ]; then
    GROWTH_RATIO=$((AOF_SIZE * 100 / AOF_BASE_SIZE))
    if [ $GROWTH_RATIO -gt 500 ]; then
        echo "WARNING: AOF file has grown to ${GROWTH_RATIO}% of base size"
    fi
fi

echo "Persistence monitoring completed"</code></pre>

            <h3>Alerting Thresholds</h3>
            
            <h4>Recommended Alert Conditions</h4>
            <table border="1">
                <tr>
                    <th>Metric</th>
                    <th>Warning Threshold</th>
                    <th>Critical Threshold</th>
                    <th>Action</th>
                </tr>
                <tr>
                    <td>RDB Save Age</td>
                    <td>24 hours</td>
                    <td>48 hours</td>
                    <td>Trigger manual BGSAVE</td>
                </tr>
                <tr>
                    <td>RDB Save Failure</td>
                    <td>-</td>
                    <td>Any failure</td>
                    <td>Check disk space and permissions</td>
                </tr>
                <tr>
                    <td>AOF Size Growth</td>
                    <td>300% of base</td>
                    <td>500% of base</td>
                    <td>Trigger AOF rewrite</td>
                </tr>
                <tr>
                    <td>Disk Space</td>
                    <td>80% full</td>
                    <td>90% full</td>
                    <td>Clean old backups, expand storage</td>
                </tr>
                <tr>
                    <td>Save Duration</td>
                    <td>5 minutes</td>
                    <td>15 minutes</td>
                    <td>Check I/O performance</td>
                </tr>
            </table>
        </section>

        <section>
            <h2>Troubleshooting Common Issues</h2>
            
            <h3>RDB Issues</h3>
            
            <h4>RDB Save Failures</h4>
            <pre><code># Common RDB problems and solutions

# Problem: Background save failed
# Check: Disk space
df -h /var/lib/redis

# Check: Permissions
ls -la /var/lib/redis/
sudo chown redis:redis /var/lib/redis

# Check: Memory for fork
free -h
# Ensure you have enough free memory for fork operation

# Check: Redis logs
tail -f /var/log/redis/redis-server.log

# Manual save for testing
redis-cli SAVE  # This will block but show any errors</code></pre>

            <h4>Large RDB Files</h4>
            <pre><code># Dealing with large RDB files

# Check what's using memory
redis-cli --bigkeys

# Analyze memory usage
redis-cli MEMORY USAGE key_name

# Consider compression
CONFIG GET rdbcompression  # Should be "yes"

# Split large datasets
# Move some data to different Redis instances
# Use Redis Cluster for automatic sharding</code></pre>

            <h3>AOF Issues</h3>
            
            <h4>AOF Corruption</h4>
            <pre><code># Fixing corrupted AOF files

# Check AOF integrity
redis-check-aof /var/lib/redis/appendonly.aof

# Fix truncated AOF (removes corrupted part)
redis-check-aof --fix /var/lib/redis/appendonly.aof

# Backup before fixing
cp /var/lib/redis/appendonly.aof /var/lib/redis/appendonly.aof.backup

# If AOF is completely corrupted, you can:
# 1. Disable AOF temporarily
CONFIG SET appendonly no

# 2. Start with RDB only
# 3. Re-enable AOF after recovery
CONFIG SET appendonly yes</code></pre>

            <h4>AOF Performance Issues</h4>
            <pre><code># Optimizing AOF performance

# Check current settings
CONFIG GET appendfsync
CONFIG GET no-appendfsync-on-rewrite

# Temporary performance boost during high load
CONFIG SET appendfsync no
# Remember to change back later!
CONFIG SET appendfsync everysec

# Monitor I/O wait
iostat -x 1

# Consider moving AOF to faster storage
# Or use appendfsync everysec instead of always</code></pre>

            <h3>Disk Space Issues</h3>
            
            <h4>Managing Storage</h4>
            <pre><code># Emergency disk space recovery

# Find large files
du -sh /var/lib/redis/*
du -sh /backups/redis/*

# Clean old backups
find /backups/redis -mtime +7 -delete

# Compress existing files
gzip /backups/redis/*.rdb
gzip /backups/redis/*.aof

# Temporary: Disable saves to prevent fills
CONFIG SET save ""
CONFIG SET appendonly no

# Long-term solutions:
# 1. Add more disk space
# 2. Move to larger volume
# 3. Set up log rotation
# 4. Implement data expiration policies</code></pre>
        </section>

        <section>
            <h2>Performance Impact Analysis</h2>
            
            <h3>Measuring Persistence Overhead</h3>
            
            <h4>Benchmarking Script</h4>
            <pre><code>#!/bin/bash
# Benchmark persistence impact

echo "Testing Redis performance with different persistence settings"

# Test function
run_benchmark() {
    local test_name=$1
    echo "Running test: $test_name"
    redis-benchmark -t set,get -n 100000 -q -c 50 -P 16
}

# Test 1: No persistence
redis-cli CONFIG SET save ""
redis-cli CONFIG SET appendonly no
run_benchmark "No persistence"

# Test 2: RDB only
redis-cli CONFIG SET save "900 1 300 10 60 1000"
redis-cli CONFIG SET appendonly no
run_benchmark "RDB only"

# Test 3: AOF everysec
redis-cli CONFIG SET save ""
redis-cli CONFIG SET appendonly yes
redis-cli CONFIG SET appendfsync everysec
run_benchmark "AOF everysec"

# Test 4: AOF always
redis-cli CONFIG SET appendfsync always
run_benchmark "AOF always"

# Test 5: Mixed mode
redis-cli CONFIG SET save "900 1 300 10 60 1000"
redis-cli CONFIG SET appendonly yes
redis-cli CONFIG SET appendfsync everysec
redis-cli CONFIG SET aof-use-rdb-preamble yes
run_benchmark "Mixed mode"</code></pre>

            <h3>Performance Guidelines</h3>
            
            <table border="1">
                <tr>
                    <th>Configuration</th>
                    <th>Write Performance</th>
                    <th>Recovery Time</th>
                    <th>Durability</th>
                    <th>Use Case</th>
                </tr>
                <tr>
                    <td>No persistence</td>
                    <td>100%</td>
                    <td>Instant</td>
                    <td>None</td>
                    <td>Pure cache</td>
                </tr>
                <tr>
                    <td>RDB only</td>
                    <td>95-98%</td>
                    <td>Fast</td>
                    <td>Low</td>
                    <td>Analytics, sessions</td>
                </tr>
                <tr>
                    <td>AOF everysec</td>
                    <td>85-90%</td>
                    <td>Medium</td>
                    <td>High</td>
                    <td>Most applications</td>
                </tr>
                <tr>
                    <td>AOF always</td>
                    <td>60-70%</td>
                    <td>Slow</td>
                    <td>Maximum</td>
                    <td>Financial systems</td>
                </tr>
                <tr>
                    <td>Mixed mode</td>
                    <td>85-90%</td>
                    <td>Fast</td>
                    <td>High</td>
                    <td>Best of both</td>
                </tr>
            </table>
        </section>

        <section>
            <h2>Next Steps</h2>
            <p>With a solid understanding of Redis persistence strategies, you're now equipped to ensure your data survives any system failure. In the next posts of this series, we'll explore:</p>
            <ul>
                <li><strong>Redis Replication and High Availability:</strong> Master-slave setups and Redis Sentinel</li>
                <li><strong>Scaling with Redis Clustering:</strong> Horizontal scaling and data distribution</li>
                <li><strong>Advanced Features:</strong> Pub/Sub messaging, Lua scripting, and modules</li>
            </ul>
        </section>

        <section>
            <h2>Key Takeaways</h2>
            <ul>
                <li>Choose persistence strategy based on your durability and performance requirements</li>
                <li>RDB snapshots are great for backups and fast recovery</li>
                <li>AOF logging provides better durability with minimal data loss</li>
                <li>Mixed mode combines the benefits of both RDB and AOF</li>
                <li>appendfsync everysec is the recommended setting for most use cases</li>
                <li>Implement comprehensive backup strategies with multiple retention levels</li>
                <li>Monitor persistence metrics and set up appropriate alerting</li>
                <li>Practice recovery procedures before you need them</li>
                <li>Consider performance impact when choosing persistence settings</li>
                <li>Regular testing of backups is essential for disaster recovery</li>
            </ul>
        </section>

        <section>
            <h2>Practice Exercises</h2>
            <ol>
                <li>Set up a Redis instance with mixed persistence mode</li>
                <li>Create automated backup scripts for your environment</li>
                <li>Practice recovery from both RDB and AOF backups</li>
                <li>Benchmark the performance impact of different persistence settings</li>
                <li>Implement monitoring for persistence metrics</li>
                <li>Create a disaster recovery plan for your Redis deployment</li>
                <li>Test AOF corruption scenarios and recovery procedures</li>
            </ol>
        </section>

        <section>
            <h2>Further Reading</h2>
            <ul>
                <li><a href="https://redis.io/topics/persistence">Official Redis Persistence Documentation</a></li>
                <li><a href="https://redis.io/topics/admin">Redis Administration Guide</a></li>
                <li><a href="https://redis.io/topics/config">Redis Configuration Guide</a></li>
                <li><a href="https://redis.io/topics/disk-storage">Redis Disk Storage Options</a></li>
                <li><a href="https://redis.io/topics/latency">Redis Latency Monitoring</a></li>
                <li><a href="https://redis.io/topics/problems">Redis Common Problems</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <hr>
        <p><em>This is the fourth post in our comprehensive Redis series. You now have the knowledge to implement robust data persistence strategies for production Redis deployments.</em></p>
        <p><strong>Previous:</strong> <a href="03-essential-redis-commands-operations.html">Essential Redis Commands and Operations</a></p>
        <p><strong>Next up:</strong> Redis Replication and High Availability</p>
    </footer>
</body>
</html>
