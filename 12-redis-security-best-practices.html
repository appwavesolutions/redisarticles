<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Security Best Practices: Protecting Your Data</title>
</head>
<body>
    <header>
        <h1>Redis Security Best Practices: Protecting Your Data</h1>
        <p><em>Comprehensive security guide for production Redis deployments</em></p>
        <p><strong>Published:</strong> Blog Post #12 of Redis Mastery Series</p>
    </header>

    <main>
        <section>
            <h2>Introduction</h2>
            <p>Redis security is critical for protecting sensitive data and preventing unauthorized access. This guide covers authentication, access control, network security, encryption, and operational security practices for production Redis deployments.</p>
        </section>

        <section>
            <h2>Authentication and Access Control</h2>
            
            <h3>Basic Authentication</h3>
            <pre><code># Set password in redis.conf
requirepass your_very_strong_password

# Or set at runtime
CONFIG SET requirepass "your_very_strong_password"

# Client authentication
AUTH your_very_strong_password

# Connection with password
redis-cli -a your_very_strong_password</code></pre>

            <h3>Redis 6+ ACL (Access Control Lists)</h3>
            <pre><code># Create users with specific permissions
ACL SETUSER alice on >alice_password ~app:* +@read +@write -@dangerous

# User permissions breakdown:
# on: user is active
# >password: set password
# ~app:*: can access keys matching "app:*"
# +@read: allow read commands
# +@write: allow write commands  
# -@dangerous: deny dangerous commands

# Create read-only user
ACL SETUSER readonly on >readonly_pass ~* +@read -@write -@admin

# Create admin user
ACL SETUSER admin on >admin_pass ~* +@all

# List users
ACL LIST

# Get user info
ACL GETUSER alice

# Delete user
ACL DELUSER alice</code></pre>

            <h3>Python ACL Implementation</h3>
            <pre><code>import redis

class RedisACLManager:
    def __init__(self, admin_host='localhost', admin_port=6379, admin_password=None):
        self.redis_admin = redis.Redis(
            host=admin_host, 
            port=admin_port, 
            password=admin_password,
            decode_responses=True
        )
    
    def create_application_user(self, username: str, password: str, key_patterns: list, permissions: list):
        """Create user for application with specific permissions"""
        
        # Build ACL command
        acl_rules = [
            'on',  # Activate user
            f'>{password}',  # Set password
        ]
        
        # Add key patterns
        for pattern in key_patterns:
            acl_rules.append(f'~{pattern}')
        
        # Add permissions
        for permission in permissions:
            acl_rules.append(f'+{permission}')
        
        # Create user
        try:
            self.redis_admin.execute_command('ACL', 'SETUSER', username, *acl_rules)
            return True
        except redis.RedisError as e:
            print(f"Failed to create user {username}: {e}")
            return False
    
    def create_readonly_user(self, username: str, password: str, key_patterns: list = ['*']):
        """Create read-only user"""
        permissions = ['@read', '-@write', '-@admin', '-@dangerous']
        return self.create_application_user(username, password, key_patterns, permissions)
    
    def create_readwrite_user(self, username: str, password: str, key_patterns: list):
        """Create read-write user for specific patterns"""
        permissions = ['@read', '@write', '-@admin', '-@dangerous']
        return self.create_application_user(username, password, key_patterns, permissions)
    
    def revoke_user_access(self, username: str):
        """Disable user access"""
        try:
            self.redis_admin.execute_command('ACL', 'SETUSER', username, 'off')
            return True
        except redis.RedisError as e:
            print(f"Failed to revoke access for {username}: {e}")
            return False
    
    def audit_users(self):
        """Audit all users and their permissions"""
        try:
            users = self.redis_admin.execute_command('ACL', 'LIST')
            audit_report = []
            
            for user_info in users:
                # Parse user info (simplified)
                if 'user' in user_info:
                    username = user_info.split()[1]
                    audit_report.append({
                        'username': username,
                        'rules': user_info,
                        'active': 'on' in user_info,
                        'has_password': '>' in user_info
                    })
            
            return audit_report
        except redis.RedisError as e:
            print(f"Audit failed: {e}")
            return []

# Usage example
acl_manager = RedisACLManager(admin_password='admin_password')

# Create users for different roles
acl_manager.create_readonly_user('analytics_user', 'analytics_pass', ['analytics:*', 'metrics:*'])
acl_manager.create_readwrite_user('app_user', 'app_pass', ['app:*', 'session:*', 'cache:*'])

# Audit users
audit = acl_manager.audit_users()
for user in audit:
    print(f"User: {user['username']}, Active: {user['active']}")</code></pre>
        </section>

        <section>
            <h2>Network Security</h2>
            
            <h3>Binding and Network Configuration</h3>
            <pre><code># Secure network binding in redis.conf
# Only bind to specific interfaces
bind 127.0.0.1 10.0.0.10

# Enable protected mode
protected-mode yes

# Change default port
port 6380

# Disable dangerous commands
rename-command FLUSHALL ""
rename-command FLUSHDB ""
rename-command DEBUG ""
rename-command CONFIG "CONFIG_b840fc02d524045429941cc15f59e41cb7be6c52"</code></pre>

            <h3>TLS/SSL Encryption (Redis 6+)</h3>
            <pre><code># Enable TLS in redis.conf
port 0  # Disable non-TLS port
tls-port 6380

# Certificate files
tls-cert-file /etc/redis/tls/redis.crt
tls-key-file /etc/redis/tls/redis.key
tls-ca-cert-file /etc/redis/tls/ca.crt

# Client certificate verification
tls-auth-clients yes

# TLS protocols
tls-protocols "TLSv1.2 TLSv1.3"

# Cipher suites
tls-ciphersuites TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256</code></pre>

            <h3>Firewall Configuration</h3>
            <pre><code># iptables rules for Redis security
# Allow Redis access only from application servers
iptables -A INPUT -p tcp --dport 6379 -s 10.0.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j DROP

# Allow Redis Sentinel access
iptables -A INPUT -p tcp --dport 26379 -s 10.0.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 26379 -j DROP

# Block all other access
iptables -A INPUT -p tcp --dport 6379 -j DROP</code></pre>

            <h3>VPN and Private Networks</h3>
            <pre><code># Deploy Redis in private subnet
# AWS Security Group example
{
  "GroupId": "sg-redis-private",
  "IpPermissions": [
    {
      "IpProtocol": "tcp",
      "FromPort": 6379,
      "ToPort": 6379,
      "UserIdGroupPairs": [
        {
          "GroupId": "sg-application-servers"
        }
      ]
    }
  ]
}</code></pre>
        </section>

        <section>
            <h2>Data Protection and Encryption</h2>
            
            <h3>Encryption at Rest</h3>
            <pre><code># File system level encryption
# Use encrypted storage volumes
# AWS EBS encryption, Azure Disk Encryption, etc.

# Application level encryption example
import redis
import cryptography.fernet

class EncryptedRedisClient:
    def __init__(self, redis_client, encryption_key):
        self.redis = redis_client
        self.cipher = cryptography.fernet.Fernet(encryption_key)
    
    def set(self, key: str, value: str, **kwargs):
        """Set encrypted value"""
        encrypted_value = self.cipher.encrypt(value.encode())
        return self.redis.set(key, encrypted_value, **kwargs)
    
    def get(self, key: str) -> str:
        """Get and decrypt value"""
        encrypted_value = self.redis.get(key)
        if encrypted_value:
            decrypted = self.cipher.decrypt(encrypted_value)
            return decrypted.decode()
        return None
    
    def hset(self, name: str, key: str, value: str):
        """Set encrypted hash field"""
        encrypted_value = self.cipher.encrypt(value.encode())
        return self.redis.hset(name, key, encrypted_value)
    
    def hget(self, name: str, key: str) -> str:
        """Get and decrypt hash field"""
        encrypted_value = self.redis.hget(name, key)
        if encrypted_value:
            decrypted = self.cipher.decrypt(encrypted_value)
            return decrypted.decode()
        return None

# Usage
encryption_key = cryptography.fernet.Fernet.generate_key()
redis_client = redis.Redis(decode_responses=False)  # Important: don't decode for encryption
encrypted_redis = EncryptedRedisClient(redis_client, encryption_key)

# Store sensitive data encrypted
encrypted_redis.set('user:1000:ssn', '123-45-6789')
encrypted_redis.hset('user:1000:profile', 'email', 'sensitive@example.com')</code></pre>

            <h3>Sensitive Data Handling</h3>
            <pre><code># Data classification and handling
class SensitiveDataManager:
    def __init__(self, redis_client, encryption_key):
        self.redis = redis_client
        self.cipher = cryptography.fernet.Fernet(encryption_key)
        
        # Data classification
        self.sensitive_patterns = [
            'ssn:', 'credit_card:', 'password:', 'api_key:', 'token:'
        ]
    
    def is_sensitive_key(self, key: str) -> bool:
        """Check if key contains sensitive data"""
        return any(pattern in key.lower() for pattern in self.sensitive_patterns)
    
    def set_with_classification(self, key: str, value: str, ttl: int = None):
        """Set value with automatic encryption for sensitive data"""
        if self.is_sensitive_key(key):
            # Encrypt sensitive data
            encrypted_value = self.cipher.encrypt(value.encode())
            result = self.redis.set(key, encrypted_value)
            
            # Set shorter TTL for sensitive data
            if ttl:
                self.redis.expire(key, min(ttl, 3600))  # Max 1 hour for sensitive data
            else:
                self.redis.expire(key, 1800)  # Default 30 minutes
                
            # Log access (for audit)
            self.log_sensitive_access('SET', key)
            return result
        else:
            # Store non-sensitive data normally
            return self.redis.set(key, value, ex=ttl)
    
    def get_with_classification(self, key: str):
        """Get value with automatic decryption for sensitive data"""
        if self.is_sensitive_key(key):
            encrypted_value = self.redis.get(key)
            if encrypted_value:
                self.log_sensitive_access('GET', key)
                decrypted = self.cipher.decrypt(encrypted_value)
                return decrypted.decode()
            return None
        else:
            return self.redis.get(key)
    
    def log_sensitive_access(self, operation: str, key: str):
        """Log access to sensitive data for audit"""
        import time
        log_entry = {
            'timestamp': time.time(),
            'operation': operation,
            'key': key,
            'user': 'current_user'  # Get from context
        }
        # Store in secure audit log
        self.redis.lpush('audit:sensitive_access', str(log_entry))
        self.redis.ltrim('audit:sensitive_access', 0, 9999)  # Keep last 10k entries</code></pre>
        </section>

        <section>
            <h2>Operational Security</h2>
            
            <h3>Secure Configuration Management</h3>
            <pre><code># Use environment variables for sensitive config
# docker-compose.yml
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - ./redis.conf:/usr/local/etc/redis/redis.conf
    networks:
      - redis_network

networks:
  redis_network:
    driver: bridge
    internal: true</code></pre>

            <h3>Security Auditing</h3>
            <pre><code>#!/bin/bash
# Redis security audit script

REDIS_HOST="localhost"
REDIS_PORT="6379"
REDIS_PASSWORD=""

echo "=== Redis Security Audit ==="

# Check authentication
echo "1. Authentication Status:"
if redis-cli -h $REDIS_HOST -p $REDIS_PORT ping 2>/dev/null | grep -q PONG; then
    echo "   ❌ No authentication required"
else
    echo "   ✅ Authentication enabled"
fi

# Check for default password
if redis-cli -h $REDIS_HOST -p $REDIS_PORT -a "foobared" ping 2>/dev/null | grep -q PONG; then
    echo "   ❌ Default password 'foobared' in use"
fi

# Check dangerous commands
echo "2. Dangerous Commands:"
DANGEROUS_COMMANDS=("FLUSHALL" "FLUSHDB" "DEBUG" "CONFIG" "SHUTDOWN")
for cmd in "${DANGEROUS_COMMANDS[@]}"; do
    if redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD $cmd 2>&1 | grep -q "unknown command"; then
        echo "   ✅ $cmd is disabled"
    else
        echo "   ❌ $cmd is available"
    fi
done

# Check network binding
echo "3. Network Configuration:"
BIND_INFO=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD CONFIG GET bind)
echo "   Bind addresses: $BIND_INFO"

# Check protected mode
PROTECTED_MODE=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD CONFIG GET protected-mode)
echo "   Protected mode: $PROTECTED_MODE"

# Check ACL users (Redis 6+)
echo "4. ACL Users:"
ACL_USERS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD ACL LIST 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$ACL_USERS"
else
    echo "   ACL not available (Redis < 6.0)"
fi

echo "=== Audit Complete ==="</code></pre>

            <h3>Monitoring Security Events</h3>
            <pre><code>import redis
import time
import json
from datetime import datetime

class RedisSecurityMonitor:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.security_events = []
    
    def monitor_failed_auth(self):
        """Monitor authentication failures"""
        # This would require custom Redis module or log parsing
        # Simulated implementation
        pass
    
    def monitor_dangerous_commands(self):
        """Monitor execution of dangerous commands"""
        dangerous_commands = ['FLUSHALL', 'FLUSHDB', 'DEBUG', 'SHUTDOWN', 'CONFIG']
        
        # Use Redis MONITOR command (performance impact in production)
        pubsub = self.redis.pubsub()
        pubsub.psubscribe('__redis__:*')
        
        for message in pubsub.listen():
            if message['type'] == 'pmessage':
                command_data = message['data']
                for dangerous_cmd in dangerous_commands:
                    if dangerous_cmd in command_data.upper():
                        self.log_security_event('dangerous_command', {
                            'command': command_data,
                            'timestamp': datetime.now().isoformat()
                        })
    
    def audit_user_permissions(self):
        """Audit user permissions and access patterns"""
        try:
            # Get all ACL users
            users = self.redis.execute_command('ACL', 'LIST')
            
            audit_results = []
            for user_info in users:
                if 'user' in user_info:
                    username = user_info.split()[1]
                    
                    # Check for overly permissive users
                    if '+@all' in user_info:
                        self.log_security_event('overpermissive_user', {
                            'username': username,
                            'permissions': user_info
                        })
                    
                    # Check for users without passwords
                    if 'nopass' in user_info:
                        self.log_security_event('user_no_password', {
                            'username': username
                        })
                    
                    audit_results.append({
                        'username': username,
                        'rules': user_info,
                        'risk_level': self.assess_user_risk(user_info)
                    })
            
            return audit_results
            
        except redis.RedisError as e:
            self.log_security_event('audit_failed', {'error': str(e)})
            return []
    
    def assess_user_risk(self, user_info: str) -> str:
        """Assess risk level of user permissions"""
        if '+@all' in user_info:
            return 'HIGH'
        elif 'nopass' in user_info:
            return 'HIGH'
        elif '+@dangerous' in user_info:
            return 'MEDIUM'
        elif '+@admin' in user_info:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def log_security_event(self, event_type: str, event_data: dict):
        """Log security events for analysis"""
        event = {
            'type': event_type,
            'timestamp': datetime.now().isoformat(),
            'data': event_data
        }
        
        self.security_events.append(event)
        
        # Store in Redis for persistence
        self.redis.lpush('security:events', json.dumps(event))
        self.redis.ltrim('security:events', 0, 9999)  # Keep last 10k events
        
        # Alert on critical events
        if event_type in ['dangerous_command', 'overpermissive_user']:
            self.send_security_alert(event)
    
    def send_security_alert(self, event: dict):
        """Send security alert (implement based on your alerting system)"""
        print(f"🚨 SECURITY ALERT: {event['type']} - {event['data']}")
        # Implement: email, Slack, PagerDuty, etc.
    
    def generate_security_report(self):
        """Generate security report"""
        user_audit = self.audit_user_permissions()
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'user_audit': user_audit,
            'recent_events': self.security_events[-50:],  # Last 50 events
            'risk_summary': {
                'high_risk_users': len([u for u in user_audit if u['risk_level'] == 'HIGH']),
                'medium_risk_users': len([u for u in user_audit if u['risk_level'] == 'MEDIUM']),
                'total_events': len(self.security_events)
            }
        }
        
        return report

# Usage
redis_client = redis.Redis(decode_responses=True)
security_monitor = RedisSecurityMonitor(redis_client)

# Generate security report
report = security_monitor.generate_security_report()
print(f"Security Report: {json.dumps(report, indent=2)}")</code></pre>
        </section>

        <section>
            <h2>Compliance and Regulatory Considerations</h2>
            
            <h3>GDPR Compliance</h3>
            <pre><code>class GDPRCompliantRedisManager:
    def __init__(self, redis_client, encryption_key):
        self.redis = redis_client
        self.cipher = cryptography.fernet.Fernet(encryption_key)
    
    def store_personal_data(self, user_id: str, data_type: str, value: str, 
                          retention_days: int = 30):
        """Store personal data with GDPR compliance"""
        key = f"personal:{user_id}:{data_type}"
        
        # Encrypt personal data
        encrypted_value = self.cipher.encrypt(value.encode())
        
        # Store with retention period
        self.redis.set(key, encrypted_value, ex=retention_days * 86400)
        
        # Log for audit trail
        self.log_personal_data_access('STORE', user_id, data_type)
        
        # Track data for deletion requests
        self.redis.sadd(f"gdpr:user_data:{user_id}", key)
        self.redis.expire(f"gdpr:user_data:{user_id}", retention_days * 86400)
    
    def get_personal_data(self, user_id: str, data_type: str):
        """Retrieve personal data with logging"""
        key = f"personal:{user_id}:{data_type}"
        
        encrypted_value = self.redis.get(key)
        if encrypted_value:
            self.log_personal_data_access('ACCESS', user_id, data_type)
            decrypted = self.cipher.decrypt(encrypted_value)
            return decrypted.decode()
        return None
    
    def delete_user_data(self, user_id: str):
        """Delete all personal data for user (right to be forgotten)"""
        # Get all keys for user
        user_keys = self.redis.smembers(f"gdpr:user_data:{user_id}")
        
        if user_keys:
            # Delete all personal data
            self.redis.delete(*user_keys)
            
            # Remove tracking set
            self.redis.delete(f"gdpr:user_data:{user_id}")
            
            # Log deletion
            self.log_personal_data_access('DELETE_ALL', user_id, 'all')
            
            return len(user_keys)
        return 0
    
    def export_user_data(self, user_id: str):
        """Export all personal data for user (data portability)"""
        user_keys = self.redis.smembers(f"gdpr:user_data:{user_id}")
        exported_data = {}
        
        for key in user_keys:
            encrypted_value = self.redis.get(key)
            if encrypted_value:
                try:
                    decrypted = self.cipher.decrypt(encrypted_value)
                    data_type = key.decode().split(':')[-1]
                    exported_data[data_type] = decrypted.decode()
                except Exception as e:
                    exported_data[key.decode()] = f"Error decrypting: {e}"
        
        self.log_personal_data_access('EXPORT', user_id, 'all')
        return exported_data
    
    def log_personal_data_access(self, action: str, user_id: str, data_type: str):
        """Log personal data access for GDPR audit"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'user_id': user_id,
            'data_type': data_type,
            'operator': 'system'  # Could be actual user from context
        }
        
        self.redis.lpush('gdpr:audit_log', json.dumps(log_entry))
        self.redis.ltrim('gdpr:audit_log', 0, 99999)  # Keep audit history</code></pre>

            <h3>Data Retention Policies</h3>
            <pre><code>class DataRetentionManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.retention_policies = {
            'session_data': 24 * 3600,      # 1 day
            'cache_data': 7 * 24 * 3600,    # 1 week  
            'analytics': 90 * 24 * 3600,    # 90 days
            'audit_logs': 365 * 24 * 3600,  # 1 year
            'personal_data': 30 * 24 * 3600  # 30 days
        }
    
    def set_with_retention(self, key: str, value: str, data_category: str):
        """Set key with appropriate retention policy"""
        ttl = self.retention_policies.get(data_category, 7 * 24 * 3600)
        self.redis.set(key, value, ex=ttl)
        
        # Tag key with category for compliance tracking
        self.redis.sadd(f"retention:{data_category}", key)
        self.redis.expire(f"retention:{data_category}", ttl)
    
    def cleanup_expired_categories(self):
        """Clean up expired data by category"""
        for category in self.retention_policies:
            # Get keys that should be expired
            category_keys = self.redis.smembers(f"retention:{category}")
            expired_keys = []
            
            for key in category_keys:
                ttl = self.redis.ttl(key)
                if ttl == -2:  # Key doesn't exist
                    expired_keys.append(key)
                elif ttl == -1:  # Key exists but no expiration
                    # Force expiration based on policy
                    self.redis.expire(key, self.retention_policies[category])
            
            # Clean up expired key references
            if expired_keys:
                self.redis.srem(f"retention:{category}", *expired_keys)</code></pre>
        </section>

        <section>
            <h2>Security Checklist</h2>
            
            <h3>Pre-Production Security Checklist</h3>
            <ul>
                <li>✅ Authentication enabled (requirepass or ACL)</li>
                <li>✅ Default passwords changed</li>
                <li>✅ Dangerous commands disabled/renamed</li>
                <li>✅ Network binding restricted</li>
                <li>✅ Protected mode enabled</li>
                <li>✅ TLS encryption configured</li>
                <li>✅ Firewall rules implemented</li>
                <li>✅ ACL users with minimal permissions</li>
                <li>✅ Audit logging enabled</li>
                <li>✅ Data retention policies defined</li>
                <li>✅ Encryption for sensitive data</li>
                <li>✅ Security monitoring implemented</li>
            </ul>

            <h3>Ongoing Security Practices</h3>
            <ul>
                <li>Regular security audits</li>
                <li>Password rotation policies</li>
                <li>Access review and cleanup</li>
                <li>Security patch management</li>
                <li>Incident response procedures</li>
                <li>Backup encryption verification</li>
                <li>Compliance validation</li>
            </ul>
        </section>

        <section>
            <h2>Key Takeaways</h2>
            <ul>
                <li>Never deploy Redis without authentication in production</li>
                <li>Use ACLs for fine-grained access control</li>
                <li>Encrypt data in transit and at rest</li>
                <li>Implement network-level security controls</li>
                <li>Disable or rename dangerous commands</li>
                <li>Monitor and audit security events</li>
                <li>Comply with data protection regulations</li>
                <li>Regular security assessments are essential</li>
            </ul>
        </section>
    </main>

    <footer>
        <hr>
        <p><strong>Previous:</strong> <a href="11-redis-monitoring-performance-optimization.html">Redis Monitoring and Performance Optimization</a></p>
        <p><strong>Next up:</strong> Real-world Redis Use Cases</p>
    </footer>
</body>
</html>
